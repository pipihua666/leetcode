## 浏览器进程：

1.  渲染进程，负责将 html、css、js 渲染成用户看到的可交互页面
2.  网络进程，负责页面的网络资源加载
3.  插件进程，负责插件的运行
4.  GPU 进程，负责页面的合成
5.  浏览器进程，负责浏览器的管理

## 渲染进程：

每个 tab 都有一个渲染进程，采用沙箱进行隔离，渲染进程包括线程：

1.  GUI 线程
2.  JS 线程
3.  事件触发线程
4.  定时器触发线程
5.  http 请求线程

## 浏览器的进程间通信：

1.  浏览器进程和渲染进程之间的通信：IPC
2.  渲染进程和 GPU 进程之间的通信：GPU 进程会把图像绘制到显存中，渲染进程可以通过 IPC 把图像数据发给 GPU 进程
3.  渲染进程和网络进程之间的通信：http 请求

## ipc 进程间通信

1.  信号通信，比如 kill 9 pid
2.  管道通信，比如 ls | grep node
3.  消息队列通信，比如 mqsend、mqrecv
4.  共享内存通信，比如 shmget、shmat
5.  信号量通信，比如 semget、semop
6.  套接字通信，比如 socket

## GUI 线程和 GPU 进程的区别

1.  GUI 线程负责告诉 GPU 进程”画什么“，而 GPU 进程负责“怎么画“
2.  GUI 将布局后的几何信息生成绘制指令列表（描述每个元素的视觉呈现如颜色、边框、背景等），不直接操作像素
3.  GPU 进程将绘制指令列表交给 GPU 硬件进行渲染，生成最终的图像
4.  复杂的绘制指令（如 3d 转换）可以绕过渲染线程，直接由 GPU 处理

## 如何优化绘制

1.  使用 will-change: translateZ(0)创建独立层，但避免层爆炸，可以在浏览器的 Layers 面板看到
2.  启动了硬件加速（GPU 直接渲染）后，会自动跳过渲染线程处理，直接交给 GPU 处理，也就是不会发生重排和重绘

## http 线程和网络进程的区别

**HTTP 线程**是页面脚本与浏览器网络功能的“中介”，而**网络进程**是真正的“网络引擎”。理解两者的分工有助于优化请求性能（如减少重复 DNS 查询）和调试跨域问题。

### **1. HTTP 线程（属于渲染进程）**

- **定位**：
  - 浏览器**渲染进程**中的一个线程（通常指 `Worker Thread` 或 `Service Worker` 线程）。
  - 主要处理与页面内容直接相关的 HTTP 请求（如 `XMLHttpRequest`、`fetch`）。
- **职责**：
  - 发起页面内的 **HTTP 请求**（如 AJAX、静态资源加载）。
  - 解析部分响应头（如 `Content-Type`），但**不直接管理网络栈**。
  - 受同源策略（CORS）和浏览器安全限制约束。
- **特点**：
  - 运行在渲染进程的沙箱中，权限受限（无法直接访问系统网络接口）。
  - 每个标签页的渲染进程有独立的 HTTP 线程。

---

### **2. 网络进程（Network Process）**

- **定位**：
  - 浏览器中**独立的系统进程**（如 Chrome 的 `Network Service` 进程）。
  - 全局唯一，负责所有网络通信的底层管理。
- **职责**：
  - **统一管理网络栈**：DNS 解析、TCP 连接、TLS 握手、HTTP/2 复用等。
  - **代理所有请求**：包括渲染进程、插件进程、Service Worker 的请求。
  - **实现浏览器级功能**：缓存策略（Disk Cache）、Cookie 存储、流量节省模式。
  - **安全审查**：HSTS 强制、证书校验、恶意请求拦截。
- **特点**：
  - 直接调用操作系统网络 API（如 Windows 的 `WinINet` 或跨平台的 `libcurl`）。
  - 拥有更高的系统权限（可访问主机网络配置）。

---

### **协作流程（以加载资源为例）**

1. **HTTP 线程**（渲染进程内）：
   - 页面脚本调用 `fetch("https://example.com/data.json")`。
   - 线程将请求封装为 IPC 消息，发送给网络进程。
2. **网络进程**：
   - 检查缓存（Disk/Memory Cache）→ 若未命中，发起 DNS 查询 → 建立 TCP 连接 → 发送 HTTP 请求。
   - 接收服务器响应，处理重定向、Cookie、缓存头（如 `Cache-Control`）。
   - 将响应数据通过 IPC 返回给渲染进程的 HTTP 线程。
3. **HTTP 线程**：
   - 解析响应数据（如 JSON），触发页面回调（如 `fetch().then()`）。

---

### **为什么这样设计？**

- **安全性**：  
  网络进程集中管理敏感操作（如证书验证），避免恶意页面直接攻击网络栈。
- **性能**：
  - 复用 TCP 连接（HTTP/2 多路复用）。
  - 全局缓存共享（多个标签页可共用同一缓存）。
- **稳定性**：  
  网络崩溃不会导致页面崩溃（沙箱隔离）。

---

### **示例场景**

- **用户打开多个标签页访问同一网站**：
  - 每个标签页的 HTTP 线程独立，但网络进程会复用 TCP 连接和缓存。
- **Service Worker 拦截请求**：
  - HTTP 线程的请求先被 Service Worker 处理，再转发到网络进程。

---

## 为什么网络进程、GPU 进程崩溃、渲染进程、插件进程崩溃不会相互影响

1. 因为**沙箱机制**独立运行，和多进程架构设计

## 为什么渲染进程崩溃了不会影响其他渲染进程

1. 每个 tab 都会分配一个渲染进程，其他标签页的渲染进程不受当前崩溃页的影响，他们是隔离独立的

## 沙箱隔离的作用

1. 权限限制：
   沙箱会严格限制进程的权限（如禁止直接访问内存、磁盘、其他进程的数据）。即使崩溃，也只能破坏自己的“沙箱环境”，无法污染其他进程。

2. 资源独立：
   每个沙箱化的进程拥有独立的资源（如内存、文件句柄），崩溃时系统会自动回收这些资源，不会影响其他进程。

> 类比：
> 就像多个玻璃房（沙箱），一个房子着火（崩溃）不会烧到隔壁，因为墙壁（隔离机制）完全阻隔。

## 多进程架构的协作

1. 通信通过 IPC：
   进程间只能通过安全的 IPC（进程间通信）传递消息（而非直接共享内存）。即使一个进程崩溃，IPC 通道会断开，但其他进程仍能正常运行。

2. 主进程监控：
   浏览器的主进程（Browser Process）会监控子进程（如 GPU 进程）。如果子进程崩溃，主进程会重启它，而不影响其他进程。

> 示例：
> GPU 进程崩溃 → 浏览器主进程检测到 → 重启 GPU 进程 → 渲染进程重新连接 → 用户无感知。
